// BFN grammar https://blog.csdn.net/wzbclock/article/details/3943498

// idea demo https://jetbrains.org/intellij/sdk/docs/tutorials/custom_language_support/lexer_and_parser_definition.html

// BNF for AviatorScript https://www.yuque.com/boyan-avfmj/aviatorscript/rcx4q0

// define from https://github.com/JetBrains/Grammar-Kit/blob/master/grammars/Grammar.bnf

// BNF for EcmaScript.jj https://tomcopeland.blogs.com/EcmaScript.html

{
  classHeader = "copyrightHeader.java"
  generate = [java="8" names="long" visitor-value="R"]

  parserClass = "my.lang.parser.MyLanguageParser"
  parserUtilClass = "my.lang.parser.MyLanguageParserUtil"

  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "MyLanguage"
  psiImplClassSuffix = "Impl"
  psiPackage = "my.lang.psi"
  psiImplPackage = "my.lang.psi.impl"
  psiImplUtilClass = "my.lang.psi.MyLanguagePsiImplUtil"

  elementTypeHolderClass = "lang.psi.MyLanguageTypes"
  elementTypePrefix = "MY_"
  elementTypeClass = "my.lang.psi.MyLanguageElementType"
  tokenTypeClass = "my.lang.psi.MyLanguageTokenType"

  tokens = [

    //symbol define from https://github.com/go-lang-plugin-org/go-lang-idea-plugin/blob/master/grammars/go.bnf
    BRACE_LEFT           =  '{'
    BRACE_RIGHT          =  '}'
    BRACK_LEFT           =  '['
    BRACK_RIGHT          =  ']'
    PAREN_LEFT           =  '('
    PAREN_RIGHT          =  ')'

    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','

    EQ                   =  '=='
    ASSIGN               =  '='
    NOT_EQ               =  '!='
    NOT                  =  '!'
    PLUS_PLUS            =  '++'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    BIT_TILDE            =  '&~'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    SHIFT_LEFT_ASSIGN    =  '<<='
    SHIFT_LEFT           =  '<<'
    SEND_CHANNEL         =  '<-'
    LESS_OR_EQUAL        =  '<='
    LESS                 =  '<'
    BIT_XOR_ASSIGN       =  '^='
    BIT_XOR              =  '^'
    MUL_ASSIGN           =  '*='
    MUL                  =  '*'
    QUOTIENT_ASSIGN      =  '/='
    QUOTIENT             =  '/'
    REMAINDER_ASSIGN     =  '%='
    REMAINDER            =  '%'
    SHIFT_RIGHT_ASSIGN   =  '>>='
    SHIFT_RIGHT          =  '>>'
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    VAR_ASSIGN           =  ':='
    TRIPLE_DOT           =  '...'
    DOT                  =  '.'
    QUESTION             =  '?'
    LAMBDA_TARGET        =  '->'

    SEMICOLON_SYNTHETIC  = '<NL>'
//    TYPE_                = 'type'
    raw_string           = 'raw_string'

    // language common
    identifier = 'regexp:\w+'
    line_comment = 'regexp:##.*'
//    block_comment = 'regexp:/*..*/'

    //literal
    string = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
    number = "regexp:[+-]?(0[xX][0-9a-fA-F]+|[0-9]|[1-9]\d*N?M?|\d+(\.\d+)?([Ee][+-]?\d+)?M?)"
    number_int = "regexp:\d+"
    null = "nil"
    true = "TRUE"
    false = "FALSE"

    // keywords
    while = "while"
    try = "try"
    throw = "throw"
    finally = "finally"
    return = "return"
    new = "new"
    let = "let"
    int = "int"
    in = "in"
    if = "if"
    for = "for"
    fn = "fn"
    break = "break"
    continue = "continue"
    lambda = "lambda"
    end = "end"

  ]
}

myFile ::= codes

codes ::= statement*

statement ::=
      line_comment
    | letStatement
    | forStatement
    | whileStatement
    | breakStatement
    | continueStatement
    | ifStatement
    | threeStatement
    | fnDefineStatement
    | fnInvokeStatement
    | newStatement
    | tryStatement
    | throwStatement
    | lambdaStatement
    | assignStatement
    | returnStatement
    | allExpressStatement
    | BRACE_LEFT statement* BRACE_RIGHT [SEMICOLON] {
   mixin = "my.lang.psi.impl.MyLanguageCodeElementImpl"
   implements = "my.lang.psi.MyLanguageStatementElement"
   methods = [getName setName getNameIdentifier getPresentation]
//   recoverWhile = statementRecover
}

//private statementRecover ::= !('!' | '&' | '(' | '*' | '+' | '-' | ';' | '<-' | '^' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | fn | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | let)

letStatement ::= let refExpress ASSIGN ([new] allExpress [SEMICOLON]| statement)

forStatement ::= for identifier in allExpress [PAREN_LEFT allExpress {COMMA allExpress}*] BRACE_LEFT codes BRACE_RIGHT [SEMICOLON]

whileStatement ::= while allExpress BRACE_LEFT codes BRACE_RIGHT

breakStatement ::= break [SEMICOLON]

continueStatement ::= continue [SEMICOLON]

ifStatement ::= if allExpress BRACE_LEFT codes BRACE_RIGHT {elsif allExpress BRACE_LEFT codes BRACE_RIGHT }* {else BRACE_LEFT codes BRACE_RIGHT}? [SEMICOLON]

fnDefineStatement ::= fn identifier PAREN_LEFT [identifier {COMMA identifier}*] PAREN_RIGHT BRACE_LEFT codes BRACE_RIGHT

fnInvokeStatement ::= fnInvokeExpress [SEMICOLON]

returnStatement ::= return allExpress* [SEMICOLON]

tryStatement ::= try BRACE_LEFT codes BRACE_RIGHT {catch PAREN_LEFT (identifier [identifier] {BIT_OR identifier [identifier]}*) PAREN_RIGHT BRACE_LEFT codes BRACE_RIGHT}* finally BRACE_LEFT codes BRACE_RIGHT

throwStatement ::= throw (new fnInvokeExpress|allExpress) [SEMICOLON]

newStatement::= new fnInvokeExpress [SEMICOLON]

threeStatement ::= threeExpress [SEMICOLON]

lambdaStatement ::= lambdaExpress [SEMICOLON]

assignStatement ::= assignExpress [SEMICOLON]

allExpressStatement ::= allExpress [SEMICOLON]

assignExpress ::= refExpress ASSIGN allExpress

allExpress ::=  threeExpress | fnInvokeExpress {op allExpress}* | express | lambdaExpress

lambdaExpress ::= lambda PAREN_LEFT {identifier {COMMA identifier}*}* PAREN_RIGHT LAMBDA_TARGET codes end | PAREN_LEFT lambdaExpress PAREN_RIGHT

threeExpress ::= (fnInvokeExpress | express) QUESTION allExpress COLON allExpress

fnInvokeExpress ::= refExpress {PAREN_LEFT [int COMMA] [allExpress {COMMA (allExpress|op)}*] PAREN_RIGHT}+

express ::=  opExpress | PAREN_LEFT opExpress PAREN_RIGHT

opExpress ::= not? (fnInvokeExpress|refExpress|value) {op allExpress}*

op ::=
      PLUS                 // +
    | MINUS                // -
    | MUL                  // *
    | QUOTIENT             // /
    | REMAINDER            // %
    | LESS                 // <
    | LESS_OR_EQUAL        // <=
    | GREATER              // >
    | GREATER_OR_EQUAL     // >=
    | EQ                   // ==
    | NOT_EQ               // !=
    | BIT_AND              // &
    | BIT_OR               // |
    | BIT_XOR              // ^
    | NOT                  // !
    | COND_OR              // ||
    | COND_AND             // &&
    | BIT_TILDE            // &~


refExpress ::= (identifier {DOT identifier}* {BRACK_LEFT value BRACK_RIGHT}* | DOLLAR number) {BRACK_LEFT refExpress BRACK_RIGHT}*

value ::= number_int|string|number|boolean|null

boolean ::= true|false